---
title: "MDS analysis"
author: "Rui Costa"
date: "08/01/2019"
output: html_document
---
How to use this script: run the following preamble and skip the data processing to fit the models.
```{r}
set.seed(973009)
library(ebsurv)
#library(mstate)
#library(caret)
#library(plotrix)
#library(mg14) #devtools::install_github("mg14/mg14") will install this package (if needed)
#library(hot.deck)
#library(glmnet)
#library(randomForestSRC)
#library(cgwtools)
setwd("~/Library/Mobile\ Documents/com~apple~CloudDocs/RWORK/MDS-multistage/code")
#load objects: data, bootstrap estimation and leave-one-out estimation
load("../data/processed_data.Rdata")
# load("../data/boot_object_model1.Rdata")
# load("../data/loo_object_model1.Rdata")
# load("../data/boot_object_model2.Rdata")
# load("../data/loo_object_model2.Rdata")
#load("../data/boot_object_model4.Rdata")
#load("../data/loo_object_model4.Rdata")
```

#### Pre-processing the data

The pre-processing steps produce a data frame called 'imputedData', with the covariate data after imputation has been carried out, and a data frame called 'mdsClinicalData', with the disease progression data and unprocessed covariate data. 

```{r }
mdsClinicalData <- read.table("../data/mds.paper.clin.txt", header=T, sep="\t", fill=T, na.strings = c("NA","na")) ## Import clinical data
mdsClinicalData <- mdsClinicalData [!duplicated(mdsClinicalData$PDID),] ## remove duplicated observations
mdsClinicalData[mdsClinicalData==""] = NA #replace empty string with NAs
mdsClinicalData = mdsClinicalData[mdsClinicalData$X0.no.mut.1.seq.2.removedbyqc.3.failed <2,] ## What is 'X0.no.mut.seq.2.removedbyqc.3.failed'? Why should it be lower than 2
mdsClinicalData$IPSS.norm = factor(tolower(as.character(mdsClinicalData$IPSS.norm)), levels=c("low", "int-1", "int-2", "high")) # removes factor level "Low", keeping factor level "low"
```


```{r }
mdsGeneticData <- read.table("../data/MDS.TPD.20Nov2012.csv", sep=",", header=T, fill=T, quote = "\"") ## Genotypes
levels(mdsGeneticData$Gene)[levels(mdsGeneticData$Gene)=="SFRS2"] = "SRSF2" #correct typo in level name
levels(mdsGeneticData$Gene)[levels(mdsGeneticData$Gene)=="ENSG00000091592"] = "NLRP1" #change level name
```

Create a matrix whose i,j entry corresponds to the patient i and gene j (there are no duplicated patients or genes). 
The entry in this matrix is 3 if patient i has at least one oncogenic mutation in gene j. It is 2, if the patient has at least one possibly oncogenic mutation in this gene. Or 1 if there's at least one mutation of unknown oncogenic status in the gene.
```{r }
IDs <- mdsClinicalData$PDID#sort(setdiff(c(as.character(mds_clin$PDID), levels(mds_gen$SAMPLE.NAME)), as.character(mds_clin$PDID)[mds_clin$X0.no.mut.1.seq.2.removedbyqc.3.failed.4.remove.from.clinical > 1]))
mdsGeneticData$Gene <- factor(sub(" Coding" ,"", as.character(mdsGeneticData$Gene))) #what is this for? There isn't any " Coding" in mdsGeneticData$Gene originally!
allGenotypes <- matrix(0,nrow = length(IDs), ncol = length(levels(mdsGeneticData$Gene)))
rownames(allGenotypes) <- IDs
colnames(allGenotypes) <- levels(mdsGeneticData$Gene)
allGenotypes <- allGenotypes[rownames(allGenotypes)!="", colnames(allGenotypes)!=""]
for(i in seq_along(mdsGeneticData$Gene)){
	if(mdsGeneticData$SAMPLE.NAME[i] %in% IDs)
		allGenotypes[as.character(mdsGeneticData$SAMPLE.NAME[i]), as.character(mdsGeneticData$Gene[i])] <- max(c(3,2,1)[as.numeric(mdsGeneticData$Decision[i])], allGenotypes[as.character(mdsGeneticData$SAMPLE.NAME[i]), as.character(mdsGeneticData$Gene[i])])
}
```

Restrict to matching PDIDs, mutated genes
```{r }
genotypes <- allGenotypes[,colSums(allGenotypes)>0]
```

Create 5 indicator (binary) variables (one for each center).
```{r }
centers <- sapply(unique(1:5), function(i) mdsClinicalData$center==i) + 0
colnames(centers) <- paste("center",1:5, sep="")
```

Create object cytoMerged merging some cytogenetic variables from mdsClinicalData.
CytoMerged includes all observations on variables with prefix "CYTO_" in mdsClinicalData.
If observation i on variable "CYTO_X" is missing, observation i on variable "SEQ_X" is used (in case "SEQ_X"[i] is not also missing).

```{r }
cyto = mdsClinicalData[,grepl("CYTO_",colnames(mdsClinicalData))]
colnames(cyto) = c( "chr3" ,   "del5q" ,"del7_7q" ,"tri8"   , "del11" , "del12", "alt17q"  , "tri19"   ,"del20q" ,"delY", "other" , "complex")
ascat =  mdsClinicalData[,grepl("SEQ_",colnames(mdsClinicalData))]
colnames(ascat) = c("tri8"  , "del5"  ,"del7_7q" , "del11q" ,"del12p", "alt17q"  , "tri19" , "del20q","other")

cytoMerged = cyto
for(c in colnames(cyto))
	if(c %in% colnames(ascat))
		cytoMerged[,c][is.na(cytoMerged[,c])] = ascat[,c][is.na(cytoMerged[,c])]
```

Simplified WHO types
```{r }
#indicator variables for simplified who classes
whoSimple = data.frame(
		ra = mdsClinicalData$WHO.category %in% c("RA","RT"),
		rars = mdsClinicalData$WHO.category == "RARS",
		rars_t = mdsClinicalData$WHO.category == "RARS-T",
		rcmd = mdsClinicalData$WHO.category == "RCMD",
		rcmd_rs = mdsClinicalData$WHO.category == "RCMD-RS",
		raeb = mdsClinicalData$WHO.category %in% c("RAEB", "RAEB 1", "RAEB 2"), 
		d5q = mdsClinicalData$WHO.category == "5q-",
		cmml =  mdsClinicalData$WHO.category == "CMML",
		mds_mpn = mdsClinicalData$WHO.category == "MDSMPN",
		mds_u = mdsClinicalData$WHO.category =="MDS-U",
		mds_aml = mdsClinicalData$WHO.category ==  "AML-MDS"
) + 0

# factor vector for simplified WHO classes
whoSimpleFactor = factor(rowSums(whoSimple * rep(1:ncol(whoSimple), each=nrow(whoSimple))), labels = c("RA","RARS","RARS-T","RCMD","RCMD-RS","RAEB","5q-","CMML","MDS-MPN","MDS-U","MDS-AML"))
```

Combine into single data.frame (only covariates)
```{r }
d <- genotypes >= 3 #only oncogeneic mut
d <- d[,colSums(d) >0] # only genes mutated at least once
rawData <- data.frame(d,
		cytoMerged,
		age_log = log(as.numeric(as.character(mdsClinicalData$AGE))),
		sex = mdsClinicalData$Gender,
		pb_cytopenia = as.numeric(mdsClinicalData$PB.CYTOPENIA),
		hb = as.numeric(mdsClinicalData$HB),
		anc_log = log(as.numeric(as.character(mdsClinicalData$ANC))+1e-3),
		plt_log = log(as.numeric(mdsClinicalData$PLT)),
		bm_blasts_logit = car::logit(as.numeric(as.character(mdsClinicalData$X..BM.BLASTS))),
		ring_sideroblasts_logit = car::logit(as.numeric(as.character(mdsClinicalData$X..RING.SIDEROBLASTS))),
		ipss = as.numeric(mdsClinicalData$IPSS.norm),
		who_simple_factor = MakeInteger(whoSimpleFactor), #essentially the same as 'whoSimple' above
		center = MakeInteger(as.factor(mdsClinicalData$center)), #essentially the same as 'centers' above
		date = (as.numeric(as.Date(mdsClinicalData$DATE.OF.DIAGNOSIS, format="%d/%m/%Y"))-4122)/(365.25*5)#date is the time since the oldest diagnosis in units of 5 years
)
```

Correct covariate classes
```{r }
logical_covs<-c('ASXL1','ATRX','BCOR','BRAF','CBL','CDKN2A','CEBPA','CREBBP','CTNNA1','CUX1','DNMT3A','EP300','ETV6','EZH2','FLT3','GATA2','GNAS','IDH1','IDH2','IRF1','JAK2','KDM6A','KIT','KRAS','MLL2','MPL','NF1','NPM1','NRAS','PHF6','PTEN','PTPN11','RAD21','RUNX1','SF3B1','SH2B3','SRSF2','STAG2','TET2','TP53','U2AF1','WT1','ZRSR2','chr3','del5q','del7_7q','tri8','del11','del12','alt17q','tri19','del20q','delY','other','complex','sex','pb_cytopenia','who_simple_factor.RA','who_simple_factor.RARS','who_simple_factor.RARS.T','who_simple_factor.RCMD','who_simple_factor.RCMD.RS','who_simple_factor.RAEB','who_simple_factor.5q.','who_simple_factor.CMML','who_simple_factor.MDS.MPN','who_simple_factor.MDS.U','who_simple_factor.MDS.AML','center.1','center.2','center.3','center.4','center.5')
numeric_covs<-c('age_log','hb','anc_log','plt_log','bm_blasts_logit','ring_sideroblasts_logit','date')
factor_covs<-c('ipss')
covariate_classes<-list(logical_covs=logical_covs,numeric_covs=numeric_covs,factor_covs=factor_covs)

for (i in names(rawData)){
      class_to_assign<-c("logical","numeric","factor")[sapply(covariate_classes,function(x) i%in%x)]
      if(class_to_assign!="factor"){
        class(rawData[[i]])<-class_to_assign
      }else{
        rawData[[i]]<-as.factor(rawData[[i]])
      }
}


```

Imputation of missing values by covariate-wise hot deck imputation.
```{r }
poorMansImpute <- function(x) {x[is.na(x)] <- sample(x[!is.na(x)],sum(is.na(x)),replace = T); return(x)}
imputedData <- as.data.frame(sapply(rawData,poorMansImpute))

```

Include only patients which have a date of diagnosis, a last follow-up date, and indicator variables for death and AML progression (153 patients are excluded).
```{r }
imputedData<-imputedData[!(is.na(mdsClinicalData$DATE.OF.DIAGNOSIS)|is.na(mdsClinicalData$DATE.LAST.FU)|is.na(mdsClinicalData$OUTCOME)|is.na(mdsClinicalData$AML.PROGRESSION)),]
mdsClinicalData<-mdsClinicalData[!(is.na(mdsClinicalData$DATE.OF.DIAGNOSIS)|is.na(mdsClinicalData$DATE.LAST.FU)|is.na(mdsClinicalData$OUTCOME)|is.na(mdsClinicalData$AML.PROGRESSION)),]
```

Remove variables that are no longer of use in mdsClinicalData
```{r }
rownames(mdsClinicalData)<-mdsClinicalData$PDID
mdsClinicalData<-mdsClinicalData[c("DATE.OF.DIAGNOSIS","AML.PROGRESSION","DATE.AML.PROGRESSION","DATE.LAST.FU","OUTCOME")]
```

Change dates to numeric
```{r }
mdsClinicalData[c("DATE.OF.DIAGNOSIS","DATE.LAST.FU","DATE.AML.PROGRESSION")]<-sapply(mdsClinicalData[c("DATE.OF.DIAGNOSIS","DATE.LAST.FU","DATE.AML.PROGRESSION")], function(x) as.numeric(as.Date(x,format="%d/%m/%Y")))
```

Remove some patients with abnormal data.
```{r }
#Remove patient whose last follow-up time is the same as the date of diagnosis (excludes one patient).
imputedData<- imputedData[mdsClinicalData$DATE.OF.DIAGNOSIS!=mdsClinicalData$DATE.LAST.FU,]
mdsClinicalData<- mdsClinicalData[mdsClinicalData$DATE.OF.DIAGNOSIS!=mdsClinicalData$DATE.LAST.FU,]

#Remove patients who progressed to AML but have no date of AML progression (excludes 4).
imputedData<-imputedData[!(mdsClinicalData$AML.PROGRESSION==1&is.na(mdsClinicalData$DATE.AML.PROGRESSION)),]
mdsClinicalData<-mdsClinicalData[!(mdsClinicalData$AML.PROGRESSION==1&is.na(mdsClinicalData$DATE.AML.PROGRESSION)),]

#Remove patients whose date of AML progression is equal to the date of death (excludes 2).
imputedData<-imputedData[!(mdsClinicalData$AML.PROGRESSION==1&mdsClinicalData$OUTCOME==1&mdsClinicalData$DATE.AML.PROGRESSION==mdsClinicalData$DATE.LAST.FU),]
mdsClinicalData<-mdsClinicalData[!(mdsClinicalData$AML.PROGRESSION==1&mdsClinicalData$OUTCOME==1&mdsClinicalData$DATE.AML.PROGRESSION==mdsClinicalData$DATE.LAST.FU),]

#Remove patients who died before they progressed (excludes 12).
imputedData<-imputedData[!(mdsClinicalData$AML.PROGRESSION==1&mdsClinicalData$DATE.AML.PROGRESSION>mdsClinicalData$DATE.LAST.FU),]
mdsClinicalData<-mdsClinicalData[!(mdsClinicalData$AML.PROGRESSION==1&mdsClinicalData$DATE.AML.PROGRESSION>mdsClinicalData$DATE.LAST.FU),]

```

Convert all variables to "numeric".
```{r }
imputedData<-as.data.frame(lapply(imputedData,function(x) as.numeric(x)))
```

Center non-categorical variables to facilitate interpretation of the baseline hazard.

```{r }
imputedData[,c("age_log","hb","anc_log","plt_log","bm_blasts_logit","ring_sideroblasts_logit")]<-scale(imputedData[,c("age_log","hb","anc_log","plt_log","bm_blasts_logit","ring_sideroblasts_logit")],center = T,scale = F)

# imputedData<-scale(imputedData,center = T,scale = F)

```

To avoid confusion later on, when variables are expanded
```{r}

names(imputedData)<-sub("center.","center",names(imputedData),fixed = T)
```

Group variable names
```{r }
gene_vars<-names(imputedData)[1:43]
cytogenetic_vars<-names(imputedData)[44:55]
clinical_vars<-names(imputedData)[56:75]
nuisance_vars<-names(imputedData)[76:81]

mutation_vars<-names(imputedData)[1:55]
all_clinical_vars<-names(imputedData)[56:81]

```

Remove variables for which there is no variation in the data set.

```{r }
imputedData<-imputedData[,which(apply(imputedData, 2, function(x) length(unique(x)))>0)]

```


Converting the data set to 'long format'
```{r}
mstate.data<-data.frame()

for(i in 1:nrow(mdsClinicalData)){
  id<-rep(i,2)
  from<-c(1,1)
  to<-c(2,3)
  trans<-c(1,2)
  Tstart<-c(0,0)
  if(mdsClinicalData$AML.PROGRESSION[i]==1){
    Tstop<-rep(mdsClinicalData$DATE.AML.PROGRESSION[i]-mdsClinicalData$DATE.OF.DIAGNOSIS[i],2)
    time<-Tstop-Tstart
    status<-c(1,0)
    mstate.data<-rbind(mstate.data,data.frame(id=id,from=from,to=to,                                              trans=trans,Tstart=Tstart,Tstop=Tstop,time=time,status=status))
    if(mdsClinicalData$DATE.LAST.FU[i]>mdsClinicalData$DATE.AML.PROGRESSION[i]){
      id<-i
      from<-2
      to<-4
      trans<-3
      Tstart<-Tstop[1]
      Tstop<-mdsClinicalData$DATE.LAST.FU[i]-mdsClinicalData$DATE.OF.DIAGNOSIS[i]
      time<-Tstop-Tstart
      status<-mdsClinicalData$OUTCOME[i]
      mstate.data<-rbind(mstate.data,data.frame(id=id,from=from,to=to,trans=trans,
                                              Tstart=Tstart,Tstop=Tstop,time=time,status=status))
    }
    next 
  }else{
    Tstop<-rep(mdsClinicalData$DATE.LAST.FU[i]-mdsClinicalData$DATE.OF.DIAGNOSIS[i],2)
    time<-Tstop-Tstart
    status<-c(0,mdsClinicalData$OUTCOME[i])
    mstate.data<-rbind(mstate.data,data.frame(id=id,from=from,to=to,
                             trans=trans,Tstart=Tstart,Tstop=Tstop,time=time,status=status))
  }
}

#check that no rows have NA's
mstate.data[apply(mstate.data,1,function(x) sum(is.na(x))>0),]

mstate.data<-cbind(mstate.data,imputedData[mstate.data$id,])
mstate.data$strata<-mstate.data$trans


```

For each transition separately, exclude variables with little variance.
```{r }

percentage_of_ones_fun<-function(x){
  sum(x)/length(x)
}
vars_to_exclude_2<-vector("list",3)
for(i in 1:3){
  dummy_dataset<-mstate.data[mstate.data$trans==i,!names(mstate.data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")]
  which_have_variance<-apply(dummy_dataset, 2, function(x) var(x)>0)
  vars_to_exclude_2[[i]]<-names(dummy_dataset)[!which_have_variance]
  dummy_dataset<-dummy_dataset[which_have_variance]
  non_categorical_vars<-c("age_log","hb","anc_log","plt_log","bm_blasts_logit","ring_sideroblasts_logit","ipss","date")
  percentage_of_ones<-apply(dummy_dataset[!names(dummy_dataset)%in%non_categorical_vars], 2, percentage_of_ones_fun)
which_less_than_five_percent<-which(percentage_of_ones<0.05)
vars_to_exclude_2[[i]]<-c(vars_to_exclude_2[[i]],names(percentage_of_ones)[which_less_than_five_percent])
}


#variables to exclude for transition 1 are the same as for transition 2
vars_to_exclude_2[[1]]==vars_to_exclude_2[[2]]

#variables to exclude for transition 3 are a subset of those for transition 1 and 2
vars_to_exclude_2[[3]]%in%vars_to_exclude_2[[2]]

#use vars_to_exclude_2[[1]] as the variables to exclude in all transitions

mstate.data<-mstate.data[!names(mstate.data)%in%vars_to_exclude_2[[1]]]
```

Sort out class and attributes of 'mstate.data'
```{r}
tmat<-transMat(x=list(c(2,3),c(4),c(),c()),names=c("MDS","AML","death","death_after_AML"))
class(mstate.data)<-c("data.frame","msdata")
attr(mstate.data,"trans")<-tmat

#save.image("../data/processed_data.Rdata")

```


#### Model estimation

Model 1: all covariates for all transitions
```{r}
#expand covariates by transition
mstate.data.expanded<-expand.covs(mstate.data,covs = names(mstate.data)[!names(mstate.data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
mstate.data.expanded<-mstate.data.expanded[!names(mstate.data.expanded)%in%setdiff(names(mstate.data),c("id","from","to","trans","Tstart","Tstop","time","status","strata","type"))]


#Objects and functions to create the 'groups' argument of coxrfx
names_list<-list(mutations=mutation_vars,clinical=all_clinical_vars)
stratum_fun<-function(x){
  strsplit_length<-length(strsplit(x,"[.]")[[1]])
  as.numeric(strsplit(x,"[.]")[[1]][strsplit_length])
}

group_function<-function(x){
  stratum<-stratum_fun(x)
  if(stratum%in%c(3)) return(paste0("single_group_",stratum))
  string_split<-strsplit(x,"[.]")[[1]]
  string_split_length<-length(string_split)
  x<-paste0(string_split[-string_split_length],collapse = ".")
  paste0(names(names_list)[sapply(names_list, function(y,x) x%in%y, x=x)],"_",stratum)
}

#argument 'groups' of coxrfx
groups<-sapply(names(mstate.data.expanded)[!names(mstate.data.expanded)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")],group_function)

#argument 'Z' of coxrfx
Z<-mstate.data.expanded[!names(mstate.data.expanded)%in%c("id","from","to","trans","Tstart","Tstop","time","status","type")]

#argument 'surv' of coxrfx
surv<-Surv(mstate.data.expanded$time,mstate.data.expanded$status)

#fit random effects model
coxrfx_object<-CoxRFX(Z,surv,groups,tmat=tmat,max.iter = 400)

# cumulative hazards and transition probabilities for patient 1
patient_data<-mstate.data[mstate.data$id==1,,drop=F][rep(1,3),]
patient_data$strata<-patient_data$trans<-1:3
patient_data<-expand.covs(patient_data,covs = names(patient_data)[!names(patient_data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
patient_data<-patient_data[names(patient_data)%in%names(mstate.data.expanded)]
msfit_object<-msfit_generic(coxrfx_object,patient_data,tmat)
probtrans_object<-probtrans_ebsurv("MDS",msfit_object,"semiMarkov",max_time = 4000)

#interval estimates
#boot_ebsurv_object<-boot_ebsurv(mstate.data.expanded,which_group = groups,min_nr_samples = 10,patient_data = patient_data,tmat = tmat,initial_state = "MDS",max_time = 4000,time_model = "semiMarkov",backup_file = "../data/boot_ebsurv_backup.Rdata",coxrfx_args = list(max.iter=200))
#save(boot_ebsurv_object,file="../data/boot_object_model1.Rdata")

#leave-one-out estimation
#patient_IDs<-sample(unique(mstate.data$id),14*14)
# loo_ebsurv_object<-loo_ebsurv(mstate.data,mstate.data.expanded,which_group = groups,patient_IDs=patient_IDs,initial_state="MDS",max_time=4000,tmat=tmat,backup_file="../data/loo_ebsurv_backup.Rdata",input_file=NULL,time_model="semiMarkov",coxrfx_args=list(max.iter=200))
#save(loo_ebsurv_object,file="../data/loo_object_model1.Rdata")
```


Model 2: same as model 1, but with transition AML->death having only clinical variables.
```{r}
#expand covariates by transition
mstate.data.expanded<-expand.covs(mstate.data,covs = names(mstate.data)[!names(mstate.data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
mstate.data.expanded<-mstate.data.expanded[!names(mstate.data.expanded)%in%setdiff(names(mstate.data),c("id","from","to","trans","Tstart","Tstop","time","status","strata","type"))]


#Objects and functions to create the 'groups' argument of coxrfx
names_list<-list(mutations=mutation_vars,clinical=all_clinical_vars)
stratum_fun<-function(x){
  strsplit_length<-length(strsplit(x,"[.]")[[1]])
  as.numeric(strsplit(x,"[.]")[[1]][strsplit_length])
}

group_function<-function(x){
  stratum<-stratum_fun(x)
  if(stratum%in%c(3)) return(paste0("single_group_",stratum))
  string_split<-strsplit(x,"[.]")[[1]]
  string_split_length<-length(string_split)
  x<-paste0(string_split[-string_split_length],collapse = ".")
  paste0(names(names_list)[sapply(names_list, function(y,x) x%in%y, x=x)],"_",stratum)
}


#clinical variables used for all transitions in the first model fitted
clinical_vars_reduced<-clinical_vars[sapply(clinical_vars,function(y) sum(grepl(y,names(mstate.data.expanded),fixed = T))>0)]

#variables used in the transition AML-> death in the first model fitted
Trans3_vars<-names(mstate.data.expanded)[grepl(".3",names(mstate.data.expanded),fixed = T)]

#non-clinical variables used in the transition AML->death in the first model fitted
Trans3_vars_no_suffix<-sub(".3","",Trans3_vars,fixed = T)
Trans3_non_clinical_vars<-Trans3_vars[!Trans3_vars_no_suffix%in%clinical_vars_reduced]

#remove all variables for transition 3 which are not clinical

mstate.data.expanded.2<-mstate.data.expanded[!names(mstate.data.expanded)%in%Trans3_non_clinical_vars]

#argument 'groups' of coxrfx
groups<-sapply(names(mstate.data.expanded.2)[!names(mstate.data.expanded.2)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")],group_function)

#argument 'Z' of coxrfx
Z<-mstate.data.expanded.2[!names(mstate.data.expanded.2)%in%c("id","from","to","trans","Tstart","Tstop","time","status","type")]

#argument 'surv' of coxrfx
surv<-Surv(mstate.data.expanded.2$time,mstate.data.expanded.2$status)

#fit random effects model
coxrfx_object2<-CoxRFX(Z,surv,groups,max.iter = 400)


# cumulative hazards and transition probabilities for patient 1
patient_data<-mstate.data[mstate.data$id==1,,drop=F][rep(1,3),]
patient_data$strata<-patient_data$trans<-1:3
patient_data<-expand.covs(patient_data,covs = names(patient_data)[!names(patient_data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
patient_data<-patient_data[names(patient_data)%in%names(mstate.data.expanded.2)]
msfit_object2<-msfit_generic(coxrfx_object2,patient_data,tmat)
probtrans_object2<-probtrans_ebsurv("MDS",msfit_object2,"semiMarkov",max_time = 4000)

#interval estimates
# boot_ebsurv_object2<-boot_ebsurv(mstate.data.expanded.2,which_group = groups,min_nr_samples = 100,patient_data = patient_data,tmat = tmat,initial_state = "MDS",max_time = 4000,time_model = "semiMarkov",backup_file = "../data/boot_ebsurv_backup2.Rdata",coxrfx_args = list(max.iter=200))
# save(boot_ebsurv_object2,file="../data/boot_object_model2.Rdata")

#leave-one-out estimation
# patient_IDs<-loo_ebsurv_object$patient_IDs
# loo_ebsurv_object2<-loo_ebsurv(mstate.data,mstate.data.expanded.2,which_group = groups,patient_IDs=patient_IDs,initial_state="MDS",max_time=4000,tmat=tmat,backup_file="../data/loo_ebsurv_backup2.Rdata",input_file=NULL,time_model="semiMarkov",coxrfx_args=list(max.iter=200))
# save(loo_ebsurv_object2,file="../data/loo_object_model2.Rdata")
```

Model 3: only clinical covariates for all transitions
```{r}
#expand covariates by transition
mstate.data.expanded<-expand.covs(mstate.data,covs = names(mstate.data)[!names(mstate.data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
mstate.data.expanded<-mstate.data.expanded[!names(mstate.data.expanded)%in%setdiff(names(mstate.data),c("id","from","to","trans","Tstart","Tstop","time","status","strata","type"))]


#Objects and functions to create the 'groups' argument of coxrfx
names_list<-list(mutations=mutation_vars,clinical=all_clinical_vars)
stratum_fun<-function(x){
  strsplit_length<-length(strsplit(x,"[.]")[[1]])
  as.numeric(strsplit(x,"[.]")[[1]][strsplit_length])
}

group_function<-function(x){
  stratum<-stratum_fun(x)
  if(stratum%in%c(3)) return(paste0("single_group_",stratum))
  string_split<-strsplit(x,"[.]")[[1]]
  string_split_length<-length(string_split)
  x<-paste0(string_split[-string_split_length],collapse = ".")
  paste0(names(names_list)[sapply(names_list, function(y,x) x%in%y, x=x)],"_",stratum)
}

#clinical variables used for all transitions in the first model fitted
clinical_vars_reduced<-clinical_vars[sapply(clinical_vars,function(y) sum(grepl(y,names(mstate.data),fixed = T))>0)]

mstate.data.3<-as.data.frame(cbind(mstate.data[1:8],mstate.data[names(mstate.data)%in%clinical_vars_reduced]))

mstate.data.3$strata<-mstate.data.3$trans

class(mstate.data.3)<-c("data.frame","msdata")
attr(mstate.data.3,"trans")<-tmat


mstate.data.expanded.3<-expand.covs(mstate.data.3,covs = names(mstate.data.3)[!names(mstate.data.3)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
mstate.data.expanded.3<-mstate.data.expanded.3[names(mstate.data.expanded.3)%in%names(mstate.data.expanded)]

stratum_fun<-function(x){
  strsplit_length<-length(strsplit(x,"[.]")[[1]])
  as.numeric(strsplit(x,"[.]")[[1]][strsplit_length])
}

group_function<-function(x){
  stratum<-stratum_fun(x)
  paste0("group_",stratum)
}

#argument 'groups' of coxrfx
groups<-sapply(names(mstate.data.expanded.3)[!names(mstate.data.expanded.3)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")],group_function)

#argument 'Z' of coxrfx
Z<-mstate.data.expanded.3[!names(mstate.data.expanded.3)%in%c("id","from","to","trans","Tstart","Tstop","time","status","type")]

#argument 'surv' of coxrfx
surv<-Surv(mstate.data.expanded.3$time,mstate.data.expanded.3$status)

#fit random effects model
coxrfx_object.3<-CoxRFX(Z,surv,groups,max.iter = 400)

# cumulative hazards and transition probabilities for patient 1
patient_data<-mstate.data.3[mstate.data.3$id==1,,drop=F][rep(1,3),]
patient_data$strata<-patient_data$trans<-1:3
patient_data<-expand.covs(patient_data,covs = names(patient_data)[!names(patient_data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")])
patient_data<-patient_data[names(patient_data)%in%names(mstate.data.expanded.3)]
msfit_object.3<-msfit_generic(coxrfx_object.3,patient_data,tmat)
probtrans_object.3<-probtrans_ebsurv("MDS",msfit_object.3,"semiMarkov",max_time = 4000)

#interval estimates
boot_ebsurv_object.3<-boot_ebsurv(mstate.data.expanded.3,which_group = groups,min_nr_samples = 100,patient_data = patient_data,tmat = tmat,initial_state = "MDS",max_time = 4000,time_model = "semiMarkov",backup_file = "../data/boot_ebsurv_backup.Rdata",coxrfx_args = list(max.iter=200))
save(boot_ebsurv_object.3,file="../data/boot_object_model3.Rdata")

#leave-one-out estimation
patient_IDs<-loo_ebsurv_object$patient_IDs
loo_ebsurv_object.3<-loo_ebsurv(mstate.data.3,mstate.data.expanded.3,which_group = groups,patient_IDs=patient_IDs,initial_state="MDS",max_time=4000,tmat=tmat,backup_file="../data/loo_ebsurv_backup.3.Rdata",input_file=NULL,time_model="semiMarkov",coxrfx_args=list(max.iter=200))
save(loo_ebsurv_object.3,file="../data/loo_object_model3.Rdata")
```

Model 4: all covariates for transitions 1 and 2, none for transition 3
```{r}
#expand covariates by transition
covariates.expanded<-mstate::expand.covs(mstate.data,covs = names(mstate.data)[!names(mstate.data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata")],append = F)

#remove all covariates for transition 3
covariates.expanded<-covariates.expanded[!grepl(".3",names(covariates.expanded),fixed = T)]

#argument 'Z' of coxrfx
Z<-data.frame(covariates.expanded,strata=mstate.data$trans)

#argument 'groups'
groups<-paste0(rep("group",ncol(Z)-1),c("_1","_2"))

#argument 'surv'
surv<-survival::Surv(mstate.data$time,mstate.data$status)

#fit random effects model
coxrfx_object.4<-CoxRFX(Z=Z,surv=surv,groups=groups,tmat = tmat)

# cumulative hazards and transition probabilities for patient 1
patient_data<-mstate.data[mstate.data$id==1,,drop=F][rep(1,3),]
patient_data$strata<-patient_data$trans<-1:3
patient_data<-mstate::expand.covs(patient_data,covs = names(patient_data)[!names(patient_data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata")],append = T)
patient_data<-patient_data[!grepl(".3",names(patient_data),fixed = T)]

msfit_object.4<-msfit_generic(coxrfx_object.4,patient_data,tmat)
probtrans_object.4<-probtrans_ebsurv("MDS",msfit_object.4,"semiMarkov",max_time = 4000)

#interval estimates
names(groups)<-names(covariates.expanded)

mstate.data.expanded<-mstate::expand.covs(mstate.data,covs = names(mstate.data)[!names(mstate.data)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata")],append = T)
mstate.data.expanded<-mstate.data.expanded[!names(mstate.data.expanded)%in%setdiff(names(mstate.data),c("id","from","to","trans","Tstart","Tstop","time","status","strata","type"))]

mstate.data.expanded<-mstate.data.expanded[!grepl(".3",names(mstate.data.expanded),fixed = T)]
boot_ebsurv_object.4<-boot_ebsurv(mstate.data.expanded,which_group = groups,min_nr_samples = 10,patient_data = patient_data,tmat = tmat,initial_state = "MDS",time_model = "semiMarkov",backup_file = "../data/boot_ebsurv_backup.Rdata",input_file =NULL ,coxrfx_args = list(max.iter=200),probtrans_args = list(max_time=4000))
# save(boot_ebsurv_object.4,file="../data/boot_object_model4.Rdata")

#leave-one-out estimation
patient_IDs<-sample(unique(mstate.data$id),2*2)
loo_ebsurv_object.4<-loo_ebsurv(mstate.data,mstate.data.expanded,which_group = groups,patient_IDs=patient_IDs,initial_state="MDS",tmat=tmat,backup_file="../data/loo_ebsurv_backup.Rdata",input_file=NULL,time_model="semiMarkov",coxrfx_args=list(max.iter=200),probtrans_args = list(max_time=4000))
#  save(loo_ebsurv_object.4,file="../data/loo_object_model4.Rdata")

```




#### Plots of estimates

Functions to generate plots of regression coefficients
```{r }
labels_fun<-function(n){
  result_pos<-vector("numeric",0)
  result_neg<-vector("numeric",0)
  for(i in 1:n){
    result_pos<-c(result_pos,c(rep(NA,8),10^i))
  }
    for(i in 1:n){
    result_neg<-c(result_neg,c(rep(NA,8),10^-i))
  }
  as.character(c(rev(result_neg),1,result_pos))
}


coefs_plot_fun<-function(k,coxrfx_object,coefficients_CIs,mar=NULL){
  #keep only covariate names from transition k
  string_split<-strsplit(names(coxrfx_object$coefficients),"[.]")
  is_name_from_trans_k<-sapply(string_split,function(x) x[length(x)]==as.character(k))
  CI_labels<-names(coxrfx_object$coefficients)[is_name_from_trans_k]
  #get rid of suffix ".k"
  CI_labels_split<-strsplit(CI_labels,"[.]")
  CI_labels<-sapply(CI_labels_split,function(x) paste0(x[-length(x)],collapse = "."))

  #simplify covariate names
  for(i in c("_simple_factor","ring_","_logit","_log")){
    CI_labels<-gsub(i,"",CI_labels)
  }
  #log-scale on the x-axis
  max_dist_x_axis<-max(abs(coefficients_CIs[c(1,2),seq(k,ncol(coefficients_CIs),3)]))
  x_axis_positive_ticks<-log(c(seq(1,9,1),seq(10,90,10),seq(100,900,100),seq(1000,9000,1000),seq(10000,100000,10000)))
  x_axis_negative_ticks<-log(c(seq(0.9,0.2,-10^(-1)),seq(0.1,0.02,-10^(-2)),seq(0.01,0.002,-10^(-3)),seq(0.001,0.0002,-10^(-4)),seq(0.0001,0.00001,-10^(-5))))
  x_axis_ticks<-c(rev(x_axis_negative_ticks),x_axis_positive_ticks)
  x_axis_labels<-labels_fun(5)
  
  par(bty="o", mgp=c(2,1.5,0))
  old_mar<-par()$mar
  if(!is.null(mar)) par(mar=mar)
  plot(1, type="n",ylab="", xlab="",yaxt="n",xaxt="n",
       xaxs="i",yaxs="i",
       xlim=c(log(0.04),log(20)),
       ylim=c(1-0.6, length(CI_labels)+0.6),cex=2)
  plotCI(add=T,y=(length(CI_labels)):1, x=coxrfx_object$coefficients[is_name_from_trans_k],ui=coefficients_CIs[2,is_name_from_trans_k],li=coefficients_CIs[1,is_name_from_trans_k],ylab="",xaxt="n",cex=1,err = "x",pch=16)
    axis(side = 1, cex=1,at = x_axis_ticks,cex.axis=1.5,labels = labels_fun(5),lwd.ticks = 3,tck=-0.02)
    axis(side = 1, cex=2,at =log(c(10^-4,10^-3,10^-2,10^-1,1,10,10^2,10^3,10^4)),cex.axis=3,labels =F,lwd.ticks = 3,tck=-0.03)
     text(labels = CI_labels,x=log(0.04)-0.5,y=length(CI_labels):1,xpd=NA,font=2,cex = 1,adj=1)
     abline(v=x_axis_ticks,lty=2,col="#999999")
      abline(v=0,lty=2,col=2)

  par(mar=old_mar)
}
```

Generate plots
```{r fig.width=12,fig.height=12}

#model1
# rfx_object<-coxrfx_object
# coefficients_CIs<-boot_ebsurv_object$coefficients_CIs
# file_name<-"../plots/coef_plots_model1.pdf"
# trans_with_covs<-c(1,2,3)

#model 2
# rfx_object<-coxrfx_object2
# coefficients_CIs<-boot_ebsurv_object2$coefficients_CIs
# file_name<-"../plots/coef_plots_model2.pdf"
# trans_with_covs<-c(1,2,3)

#model 3
# rfx_object<-coxrfx_object.3
# coefficients_CIs<-boot_ebsurv_object.3$coefficients_CIs
# file_name<-"../plots/coef_plots_model3.pdf"
# trans_with_covs<-c(1,2,3)

#model4
rfx_object<-coxrfx_object.4
coefficients_CIs<-boot_ebsurv_object.4$coefficients_CIs
file_name<-"../plots/coef_plots_model4.pdf"
trans_with_covs<-c(1,2)

pdf(file_name,width=10,height=12)
colGroups <- c(brewer.pal(12, "Paired")[c(10)],brewer.pal(12, "Paired")[c(6,4,3,5,12,9,1,2,7)],"#999999", brewer.pal(12, "Paired")[c(8)])
colGroups <- colGroups[rep(1:6,3)]
par(mfrow=c(1,2))
for(k in trans_with_covs){
  coefs_plot_fun(k,rfx_object,coefficients_CIs = coefficients_CIs,mar =c(4.1,8.6,4.1,0.4))
}
dev.off()

```

Plots of cumulative hazards with CIs for patient 1
```{r}

# model 4
cumhaz_object<-msfit_object.4
boot_object<-boot_ebsurv_object.4
file_name<-"../plots/patient1_cumhaz_model4.png"

png(file_name,width =680,height = 280)
par(mfrow=c(1,3),mar=c(2,2,2,2))
  for(transition in sort(unique(mstate.data.expanded$trans))){
    cumhaz<-cumhaz_object$Haz[cumhaz_object$Haz$trans==transition,]
    plot(cumhaz$time[sapply(seq(from=0,to=4000,length.out = 400),function(x) which.min(abs(cumhaz$time-x)))],cumhaz[sapply(seq(from=0,to=4000,length.out = 400),function(x) which.min(abs(cumhaz$time-x))),"Haz"],pch=".",ylab = "cumulative hazard",xlab = "days since diagnosis",font.main=1,type="l")
     lines(x=colnames(boot_object$cumhaz_CIs[[transition]]),y=boot_object$cumhaz_CIs[[transition]][1,],lwd=1.6,lty=2,col=2)
     lines(x=colnames(boot_object$cumhaz_CIs[[transition]]),y=boot_object$cumhaz_CIs[[transition]][2,],lwd=1.6,lty=2,col=2)
   }
  # mtext("95% bootstrap confidence intervals",outer = T,cex = 1.3,font=2,line = 1)
  dev.off()

```

Plots of transition probabilities with CIs for patient 1
```{r}
# model 1
# pt_object<-probtrans_object
# boot_object<-boot_ebsurv_object
# file_name<-"../plots/patient1_transProbs_model1.png"

# model 2
# pt_object<-probtrans_object2
# boot_object<-boot_ebsurv_object2
# file_name<-"../plots/patient1_transProbs_model2.png"

# model 3
# pt_object<-probtrans_object.3
# boot_object<-boot_ebsurv_object.3
# file_name<-"../plots/patient1_transProbs_model3.png"

# model 4
pt_object<-probtrans_object.4
boot_object<-boot_ebsurv_object.4
file_name<-"../plots/patient1_transProbs_model4.png"

png(file_name)
par(mfrow=c(2,2),mar=c(2,2,2,2))
  for(target_state in colnames(tmat)){
    if(target_state=="AML"){
      ylim_max<-0.5
    }else{
      ylim_max<-1
    }
    if(target_state=="death"){
      target_state_title<-"death_before_AML"
    }else{
      target_state_title<-target_state
    }
    plot(pt_object[[1]]$time,pt_object[[1]][,target_state],ylim = c(0,ylim_max),pch=".",ylab = "probability",xlab = "days since diagnosis",main = target_state_title,font.main=1)
    lines(x=seq(from=0,to=4000,length.out =formals(probtrans_ebsurv)$nr_steps),y=boot_object$probtrans_CIs[[target_state]][1,],lwd=1.6,lty=2,col=2)
    lines(x=seq(from=0,to=4000,length.out = formals(probtrans_ebsurv)$nr_steps),y=boot_object$probtrans_CIs[[target_state]][2,],lwd=1.6,lty=2,col=2)
  }
  mtext("95% bootstrap confidence intervals",outer = T,cex = 1.3,font=2,line = 1)
  dev.off()

```



Plots of leave-one-out personalised predictions.
```{r fig.width=10,fig.height=8}

#model 1
# probtrans_list<-loo_ebsurv_object$probtrans_objects_loo
# file_name<-"../plots/loo_pers_predictions_model1.png"

#model 2
# probtrans_list<-loo_ebsurv_object2$probtrans_objects_loo
# file_name<-"../plots/loo_pers_predictions_model2.png"

#model 3
# probtrans_list<-loo_ebsurv_object.3$probtrans_objects_loo
# file_name<-"../plots/loo_pers_predictions_model3.png"

#model 4
probtrans_list<-loo_ebsurv_object.4$probtrans_objects_loo
file_name<-"../plots/loo_pers_predictions_model4.png"


png(file_name,width = 1000,height = 800)
#order patients by survival probability at time 2000
time_vector<-probtrans_list[[1]][[1]]$time
index2000<-which.min(abs(time_vector-2000))
trans_probs_at_2000<-sapply(probtrans_list,function(x) sum(x[[1]][index2000,2:3]))
ordered_indices<-rev(order(trans_probs_at_2000))

par(mfrow=c(14,14),mar=c(0.08,0.08,0.08,0.08))
for(i in ordered_indices){
  dimnames(probtrans_list[[i]]$trans)[[2]]<-c("","","","")
  #swap order of states
  probtrans_list[[i]][[1]]<-probtrans_list[[i]][[1]][c(1,2,3,5,4)]
  plot(probtrans_list[[i]],type="filled",xlim=c(0,4000),yaxt='n',xaxt='n',lwd=c(0.001),col=c("#F4C5BF","#E2857E","#5C8191","#9DB6BD"))
  patient_data_2<-mstate.data[mstate.data$id==i,1:8]
  segments(x0=0,y0=0.5,x1=min(4000,patient_data_2$Tstop[1]),y1=0.5,xpd=T,lwd = 0.5)
  if(patient_data_2$status[2]==1){
    points(y=0.5,x=patient_data_2$Tstop[1],bg="#9DB6BD",pch=21,cex=1.7)
  }else if(patient_data_2$status[1]==1&nrow(patient_data_2)==3){
    points(y=0.5,x=patient_data_2$Tstop[2],col="red",pch=4,cex=1.7)
    segments(x0=patient_data_2$Tstop[1],y0=0.5,x1=min(4000,patient_data_2$Tstop[3]),y1=0.5,xpd=T,lwd = 1.7)
    if(patient_data_2$status[3]==1) {
      points(y=0.5,x=patient_data_2$Tstop[3],bg="#5C8191",pch=21,cex=1.7)
    }
  }else if(patient_data_2$status[1]==1&nrow(patient_data_2)==2){
    points(y=0.5,x=patient_data_2$Tstop[2],col="red",pch=4,cex=1.7)
  }
}
dev.off()
```


#### Variable contributions

Some necessary functions and objects
```{r}
#some necessary functions and other objects
VarianceComponents <- function(fit, newZ = fit$Z[setdiff(1:nrow(fit$Z), fit$na.action),], groups = fit$groups, type = c("diag","rowSums"), var=c("var2","var"),trans){
  var <- match.arg(var)
  risk <- PartialRisk(fit = fit, newZ = newZ, groups = groups,trans=trans)$pr
  type <- match.arg(type)
  #residual <- predict(fit, se.fit=TRUE)$se.fit^2
  newZ <- as.matrix(newZ - rep(colMeans(newZ), each=nrow(newZ)))
  error <- rowSums((newZ %*% fit[[var]]) * newZ)
  
  c <- cov(risk, use="complete")
  if(type=="diag")
    x <- diag(c)
  else
    x <- rowSums(c)
  return(list(out1=c(x, mean.error=mean(error)),out2=PartialRisk(fit = fit, newZ = newZ, groups = groups,trans=trans)$gr))
}

PartialRisk <- function(fit, newZ=fit$Z, groups=fit$groups,trans) {
  pr<-sapply(levels(groups)[grep(paste0("_",trans),levels(groups),fixed=TRUE)], function(x) {
    ix <- groups == x
    as.matrix(newZ[fit$strata==trans,ix, drop=FALSE]) %*% coef(fit)[ix] 
  })
  return(list(pr=pr,gr=levels(groups)[grep(paste0("_",trans),levels(groups),fixed=TRUE)]))
}


genes<-names(mstate.data)[9:51]
cytogenetics<-names(mstate.data)[52:63]
demographics<-names(mstate.data)[64:65]
blood<-names(mstate.data)[66:71]
class<-names(mstate.data)[72:83]
nuisance<-names(mstate.data)[84:89]
covariate_classes<-list(genes=genes,cytogenetics=cytogenetics,demographics=demographics,blood=blood,class=class,nuisance=nuisance)

which_group_fun<-function(x,covariate_classes_list){
    string_split<-strsplit(x,"[.]")
  if(length(string_split[[1]])==1){
    return(NULL)
  }else{
    string_split_vec<-unlist(string_split)
    primitive_name<-paste0(string_split_vec[-length(string_split_vec)],collapse = ".")
    which_class<-unlist(lapply(covariate_classes_list,function(x) is.element(primitive_name,x)))
    which_class<-names(which(which_class)==T)
    trans_sufix<-paste0("_",tail(string_split_vec,1),collapse = "")
    return(paste0(which_class,trans_sufix,collapse = ""))
  }
}

fun_ci<-function(x){
   c(quantile(x,0.025),quantile(x,0.975))
}
```

Compute bootstrap CIs of variable importances
```{r}
# Model 1:
# mstate_data_expanded<-mstate.data.expanded
# coxrfx_fits_boot<-boot_ebsurv_object$coxrfx_fits_boot

# Model 2:
# mstate_data_expanded<-mstate.data.expanded.2
# coxrfx_fits_boot<-boot_ebsurv_object2$coxrfx_fits_boot

# Model 3:
mstate_data_expanded<-mstate.data.expanded.3
coxrfx_fits_boot<-boot_ebsurv_object.3$coxrfx_fits_boot


groups<-sapply(names(mstate_data_expanded)[!names(mstate_data_expanded)%in%c("id","from","to","trans","Tstart","Tstop","time","status","strata","type")],group_function)
varcomp_groups<-unlist(sapply(names(mstate_data_expanded),which_group_fun,covariate_classes_list=covariate_classes))
varcomp_groups<-as.factor(varcomp_groups)

string_split<-sapply(names(varcomp_groups),strsplit,split="[.]")
fun1<-function(i){
  sapply(string_split, function(x) x[length(x)]==i)
}

VarComps_1<-matrix(ncol=length(unique(varcomp_groups[fun1(1)]))+1,nrow=0)
VarComps_2<-matrix(ncol=length(unique(varcomp_groups[fun1(2)]))+1,nrow=0)
VarComps_3<-matrix(ncol=length(unique(varcomp_groups[fun1(3)]))+1,nrow=0)

for(j in 1:length(coxrfx_fits_boot)){
      varcomp_groups2<-varcomp_groups[names(groups)]
      VarComps_1<-rbind(VarComps_1,VarianceComponents(coxrfx_fits_boot[[j]],groups = varcomp_groups2,type = "rowSums",trans = 1)$out1)
      VarComps_2<-rbind(VarComps_2,VarianceComponents(coxrfx_fits_boot[[j]],groups = varcomp_groups2,type = "rowSums",trans = 2)$out1)
      VarComps_3<-rbind(VarComps_3,VarianceComponents(coxrfx_fits_boot[[j]],groups = varcomp_groups2,type = "rowSums",trans = 3)$out1)
      print(j)

}

#Generate interval estimates of variable contributions; compute standard errors of estimates of variable contributions.

RelativeVarComps_1<-apply(VarComps_1[,1:(ncol(VarComps_1)-2)],1,function(x) x/sum(x))
VarComps_1_CI<-round(t(apply(RelativeVarComps_1,1,fun_ci)),2)
VarComps_1_sd<-round(t(apply(RelativeVarComps_1,1,sd)),2)

RelativeVarComps_2<-apply(VarComps_2[,1:(ncol(VarComps_2)-2)],1,function(x) x/sum(x))
VarComps_2_CI<-round(t(apply(RelativeVarComps_2,1,fun_ci)),2)
VarComps_2_sd<-round(t(apply(RelativeVarComps_2,1,sd)),2)

RelativeVarComps_3<-apply(VarComps_3[,1:(ncol(VarComps_3)-2)],1,function(x) x/sum(x))
VarComps_3_CI<-round(t(apply(RelativeVarComps_3,1,fun_ci)),2)
VarComps_3_sd<-round(t(apply(RelativeVarComps_3,1,sd)),2)

```


Plots of variable contributions

```{r}
#model 1
# mstate_data_expanded<-mstate.data.expanded
# rfx_object<-coxrfx_object
# file_name_1<-"../plots/var_comps_model1_1.png"
# file_name_2<-"../plots/var_comps_model1_2.png"
# file_name_3<-"../plots/var_comps_model1_3.png"

#model 2
# mstate_data_expanded<-mstate.data.expanded.2
# rfx_object<-coxrfx_object2
# file_name_1<-"../plots/var_comps_model2_1.png"
# file_name_2<-"../plots/var_comps_model2_2.png"
# file_name_3<-"../plots/var_comps_model2_3.png"

#model 3
mstate_data_expanded<-mstate.data.expanded.3
rfx_object<-coxrfx_object.3
file_name_1<-"../plots/var_comps_model3_1.png"
file_name_2<-"../plots/var_comps_model3_2.png"
file_name_3<-"../plots/var_comps_model3_3.png"


colGroups <- c(brewer.pal(12, "Paired")[c(10)],brewer.pal(12, "Paired")[c(6,4,3,5,12,9,1,2,7)],"#999999", brewer.pal(12, "Paired")[c(8)])
colGroups <- colGroups[rep(1:6,3)]
 
groups3<-unlist(sapply(names(mstate_data_expanded),which_group_fun,covariate_classes_list=covariate_classes))
groups3<-as.factor(groups3)

variable_importances_1<-VarianceComponents(rfx_object,groups=groups3,type="diag",trans=1)
variable_importances_2<-VarianceComponents(rfx_object,groups=groups3,type="diag",trans=2)
variable_importances_3<-VarianceComponents(rfx_object,groups=groups3,type="diag",trans=3)

bar_heights1<-variable_importances_1$out1[1:(length(variable_importances_1$out1)-1)]/sum(variable_importances_1$out1[1:(length(variable_importances_1$out1)-1)])
bar_heights2<-variable_importances_2$out1[1:(length(variable_importances_2$out1)-1)]/sum(variable_importances_2$out1[1:(length(variable_importances_2$out1)-1)])
bar_heights3<-variable_importances_3$out1[1:(length(variable_importances_3$out1)-1)]/sum(variable_importances_3$out1[1:(length(variable_importances_3$out1)-1)])
names_arg1<-gsub("_1","",names(bar_heights1))
names_arg2<-gsub("_2","",names(bar_heights2))
names_arg3<-gsub("_3","",names(bar_heights3))

error_bar_fun<-function(bar_heights,SDs){
  space_between_error_bars<-1.2
  first_bar_position<-par("usr")[3]+0.7
  for(i in 0:(length(bar_heights)-1)){
    segments(x0=bar_heights[i+1]-VarComps_1_sd[i+1],x1=bar_heights[i+1]+VarComps_1_sd[i+1],y0=first_bar_position+i*space_between_error_bars,y1=first_bar_position+i*space_between_error_bars)
  }
}


png(file_name_1,width = 500,height = 400)
par(mar =c(2.5,8.4,2.5,1.4),mgp=c(3,1,0),font.axis=1)
barplot(bar_heights1,horiz = T,xlim=c(-0.03,1.03),las=1,names.arg =names_arg1,col=colGroups[1:5],cex.names = 1,border = NA,xaxt='n')
axis(1,at=seq(0,1,0.2),tcl=-1,mgp=c(3,1,0),cex.axis=0.75)
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col = rgb(0.5,0.5,0.5,alpha=0.1), border=FALSE)
error_bar_fun(bar_heights1,VarComps_1_sd)
dev.off()

png(file_name_2,width = 500,height = 400)
par(mar =c(2.5,8.4,2.5,1.4),mgp=c(3,1,0),font.axis=1)
barplot(bar_heights2,horiz = T,xlim=c(-0.03,1.03),las=1,col=colGroups[1:5],names.arg=names_arg2,border=NA,tcl=-1,mgp=c(3,1,0),cex.axis=0.75)
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col = rgb(0.5,0.5,0.5,alpha=0.1), border=FALSE)
mtext("variable importance",side=1, outer=F,line=5,cex=1.5)
error_bar_fun(bar_heights2,VarComps_2_sd)
dev.off()

png(file_name_3,width = 500,height = 400)
par(mar =c(2.5,8.4,2.5,1.4),mgp=c(3,1,0),font.axis=1)
barplot(bar_heights3,horiz = T,xlim=c(-0.03,1.03),las=1,names.arg =names_arg3,col=colGroups[1:5],border=NA,tcl=-1,mgp=c(3,1,0),cex.axis=0.75)
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col = rgb(0.5,0.5,0.5,alpha=0.1), border=FALSE)
error_bar_fun(bar_heights3,VarComps_3_sd)
dev.off()

```


#### Cross-validated calibration plots
Built according to Gerds et al., Calibration plots for risk prediction
models in the presence of competing risks, Statistics In Medicine, 2014.

Functions

```{r fig.width=5,fig.height=4.5}
#In the next function, patient_indices should be a list where each component contains the set of patient indices in a given cross-validation fold. For each patient whose index is in patient_indices, the function returns the estimated probability that the patient is in each state at each of time_points. The model generating the probability estimates is trained on the patients whose indices do NOT belong to patient_indices. The output is a list with two components: first component is an array where the first dimension index refers to patients, the second dimension to states, and the third to time points; the second component in the list consists of the input argument 'patient_indices'.

pred_probs_fun<-function(patient_indices,time_points,states,mstate.data,mstate.data.expanded,group_function,time_model="semiMarkov",input_file=NULL,backup_file=NULL){
  if(!is.null(input_file)){
    load(input_file)
    first_i<-i
  }else{
  pred_probs_object<-vector("list",length(patient_indices))
  first_i<-1
  }
  col_names<-sapply(states,function(x) paste(x,collapse = " & "))
  for(i in first_i:length(patient_indices)){
  mstate.data.expanded.cv<-mstate.data.expanded[!mstate.data.expanded$id%in%patient_indices[[i]],]
  Z_cv<-mstate.data.expanded.cv[!names(mstate.data.expanded.cv)%in%c("id","from","to","trans","Tstart","Tstop","time","status","type")]
  Z_cv<-Z_cv[,apply(Z_cv,2,function(x) var(x)>0)]
  groups<-sapply(names(Z_cv)[names(Z_cv)!="strata"],group_function)

  #argument 'surv' of coxrfx
  if(time_model=="semiMarkov"){
    surv_cv<-Surv(mstate.data.expanded.cv$time,mstate.data.expanded.cv$status)
  }else{
    surv_cv<-Surv(mstate.data.expanded.cv$Tstart,mstate.data.expanded.cv$Tstop,mstate.data.expanded.cv$status)
  }

  #fit random effects model
  coxrfx_object_cv<-CoxRFX(Z_cv,surv_cv,groups,max.iter = 200,which.mu = NULL)
  if(!is.null(input_file) & i==first_i){
    first_j<-j
  }else{
    first_j<-1
    output<-array(dim = c(length(patient_indices[[i]]),ncol(attr(mstate.data,"trans")),length(time_points)),dimnames = list(NULL,colnames(attr(mstate.data,"trans")),paste0("t=",time_points)))
  }
  for(j in first_j:length(patient_indices[[i]])){
    patient_data<-mstate.data[rep(which(mstate.data$id==patient_indices[[i]][j]&mstate.data$trans==1),3),]
    patient_data$trans<-1:3
    patient_data<-expand.covs(patient_data,covs =names(patient_data)[-(1:8)] )
    patient_data$strata<-1:3
    msfit_object<-msfit_generic(coxrfx_object_cv,newdata=patient_data,trans=attr(mstate.data,"trans"))
    probtrans_obj<-probtrans_ebsurv("MDS",msfit_object,time_model)
    time_indices<-sapply(time_points,function(x) which.min(abs(probtrans_obj[[1]][,1]-x)))
    for(l in 1:length(time_points)){
         output[j,,l]<-unlist(probtrans_obj[[1]][time_indices[l],colnames(attr(mstate.data,"trans"))])
    }
    if(j %%20==0){
      object_list<-ls()[!ls()=="input_file"]
      save(list=object_list,file=backup_file)
      }
    print(j)
    j<-j+1
  }
  output_aggregated<-array(dim=c(dim(output)[1],length(states),dim(output)[3]),dimnames=list(NULL,col_names,paste0("t=",time_points)))
  for(k in 1:dim(output)[3]){
    output_aggregated[,,k]<-sapply(list("MDS",c("AML","death_after_AML"),"death"),function(x) rowSums(output[,x,k,drop=F]))
  }
pred_probs_object[[i]]<-output_aggregated
print(i)
  }
  list(pred_probs_object=pred_probs_object,patient_indices=patient_indices)
}



#In the next function, patient_indices should be a list where each component contains the set of patient indices in a given cross-validation fold. For each patient whose index is in patient_indices, the function returns the pseudo status of the patient at each of time_points, with regard to each of the states in argument 'states' (a state can consist of the aggregation of two or more states). The output is a list with two components: first component is an array where the first dimension index refers to patients, the second dimension to states, and the third to time points; the second component in the list consists of the input argument 'patient_indices'.

pseudo_statuses_fun<-function(patient_indices,time_points,states,mstate.data.expanded,tmat,time_model="semiMarkov"){
  pseudo_statuses<-vector("list",length(patient_indices))
  col_names<-sapply(states,function(x) paste(x,collapse = " & "))
  for(i in 1:length(patient_indices)){
    print(paste0("i=",i))
  mstate.data.expanded.cv<-mstate.data.expanded[mstate.data.expanded$id%in%patient_indices[[i]],]
  if(time_model=="semiMarkov"){
    formula_object<-formula(Surv(time,status)~strata(trans))
  }else{
    formula_object<-formula(Surv(Tstart,Tstop,status)~strata(trans))
  }
  coxph_obj<-coxph(formula_object,data = mstate.data.expanded.cv)
  msfit_obj<-msfit(coxph_obj,variance = F,trans = tmat)
  probtrans_obj<-probtrans(msfit_obj,0,variance = F)
  names(probtrans_obj[[1]])[-1]<-colnames(tmat)
  time_indices<-sapply(time_points,function(x) sum(x>=probtrans_obj[[1]]$time))
  output<-array(dim = c(length(patient_indices[[i]]),length(states),length(time_points)),dimnames =list(NULL,col_names,paste0("t=",time_points)) )
  for(j in 1:length(patient_indices[[i]])){
    print(paste0("j=",j))
    mstate.data.expanded.cv.loo<-mstate.data.expanded.cv[!mstate.data.expanded.cv$id==patient_indices[[i]][j],]
    coxph_obj_loo<-coxph(formula_object,data = mstate.data.expanded.cv.loo)
  msfit_obj_loo<-msfit(coxph_obj_loo,variance = F,trans = tmat)
  probtrans_obj_loo<-probtrans(msfit_obj_loo,0,variance = F)
  names(probtrans_obj_loo[[1]])[-1]<-colnames(tmat)
  time_indices_loo<-sapply(time_points,function(x) sum(x>=probtrans_obj_loo[[1]]$time))
  for(k in 1:length(states)){
  output[j,k,]<-length(patient_indices[[i]])*rowSums(probtrans_obj[[1]][time_indices,states[[k]],drop=F])-(length(patient_indices[[i]])-1)*rowSums(probtrans_obj_loo[[1]][time_indices_loo,states[[k]],drop=F])
  }
  }
  pseudo_statuses[[i]]<-output
  }
  list(pseudo_statuses=pseudo_statuses,patient_indices=patient_indices)
}


#fetches the predicted probabilities in pred_probs_object (and the pseudo statuses in pseudo_statuses_object) which refer to the [year]th element of the argument time_points; for each fold, identifies the patients whose predicted probabilities are in the neighbourhood of p defined by bdw (bandwidth) and returns both the average of their statuses (the 'pseudo proportion') and the average of their predicted probabilities; also returns estimates of cross-validation standard error.
pseudo_proportions_fun<-function(p,bdw,year,pred_probs_list,pseudo_statuses_list){
    pred_probs_list_t<-sapply(1:length(pred_probs_list),function(x) pred_probs_list[[x]][,attr(pseudo_statuses_list[[1]],"states"),year,drop=FALSE])
    pred_probs_list_t<-sapply(pred_probs_list_t,rowSums)
    pseudo_statuses_list_t<-sapply(1:length(pseudo_statuses_list),function(x) pseudo_statuses_list[[x]][,year])
    neighbours_of_p_indices<-sapply(pred_probs_list_t, function(x) which(abs(p-x)<bdw))
    if(sum(sapply(neighbours_of_p_indices,function(x) length(x)>0))<length(pred_probs_list)) {
      neighbours_of_p_indices<-vector("list",length(neighbours_of_p_indices))
      }
    pseudo_proportions<-sapply(1:length(pseudo_statuses_list_t),function(x) mean(pseudo_statuses_list_t[[x]][neighbours_of_p_indices[[x]]]))
    pseudo_proportions<-pseudo_proportions[!is.nan(pseudo_proportions)]
    predicted_probs_means<-sapply(1:length(pred_probs_list_t),function(x) mean(pred_probs_list_t[[x]][neighbours_of_p_indices[[x]]]))
    predicted_probs_means<-predicted_probs_means[!is.nan(predicted_probs_means)]
    return(list(pseudo_proportions=pseudo_proportions,predicted_probs_means=predicted_probs_means,sd_pseudo_proportions=sqrt(var(pseudo_proportions))/length(pred_probs_list)))
}

pseudo_proportions_fun<-function(p,bdw,time_point,state,pred_probs_object,pseudo_statuses_object){
  #in each component of the list 'pred_probs_object' keep only the vector which corresponds to the arguments 'time_point' and 'state' 
    pred_probs_reduced<-sapply(1:length(pred_probs_object),function(x) pred_probs_object[[x]][,state,paste0("t=",time_point),drop=FALSE])
  # do the same for 'pseudo_statuses_object'  
    pseudo_statuses_reduced<-sapply(1:length(pseudo_statuses_object),function(x) pseudo_statuses_object[[x]][,state,paste0("t=",time_point),drop=FALSE])
  # For each fold, find the patients whose estimated probability is within bdw of p
    neighbours_of_p_indices<-sapply(pred_probs_reduced, function(x) which(abs(p-x)<bdw))
  # if, in each fold, there isn't at least one patient whose estimated probability is within bdw of p, make neighbours_of_p_indices a vector of NULL values.
    if(sum(sapply(neighbours_of_p_indices,function(x) length(x)>0))<length(pred_probs_reduced)) {
      neighbours_of_p_indices<-vector("list",length(neighbours_of_p_indices))
    }
    #compute pseudo-proportions for each fold
    pseudo_proportions<-sapply(1:length(pseudo_statuses_reduced),function(x) mean(pseudo_statuses_reduced[[x]][neighbours_of_p_indices[[x]]]))
    pseudo_proportions<-pseudo_proportions[!is.nan(pseudo_proportions)]
    #for each fold compute the average of the estimated probabilities of those patients whose estimated probabilities are within bdw of p
    predicted_probs_means<-sapply(1:length(pred_probs_reduced),function(x) mean(pred_probs_reduced[[x]][neighbours_of_p_indices[[x]]]))
    predicted_probs_means<-predicted_probs_means[!is.nan(predicted_probs_means)]
    return(list(pseudo_proportions=pseudo_proportions,predicted_probs_means=predicted_probs_means,sd_pseudo_proportions=sqrt(var(pseudo_proportions))/length(pred_probs_reduced)))
}


#plot building function

plot_fun<-function(time_point,state,bdw,pred_probs_object,pseudo_statuses_object,col_title=NULL,row_title=NULL,row_title_line=1,row_title_cex=0.5,scale_factor,xaxt="n",yaxt="n",draw_2nd_yaxis=FALSE,...){
  # the vector of x-axis values 'p' of a given plot is the vector of estimated probabilities for all patients for the state and the time point that the plot corresponds to'
  p<-sort(unlist(sapply(1:length(pred_probs_object),function(x) pred_probs_object[[x]][,state,paste0("t=",time_point)])))
  #the empirical density of the x-values, which is also to be drawn in each plot:
  dens_p<-density(p)
  # the vector of y-values ('pseudo-proportions') of the calibration curve
  pseudo_proportions<-sapply(p,function(x) mean(pseudo_proportions_fun(p = x,bdw = bdw,time_point = time_point,state = state,pred_probs_object = pred_probs_object,pseudo_statuses_object = pseudo_statuses_object)$pseudo_proportions))
  p<-p[!is.na(pseudo_proportions)]
  pseudo_proportions<-pseudo_proportions[!is.na(pseudo_proportions)]
  #standard dev of the pseudo-proportions
  sd_pseudo_proportions<-sapply(p,function(x) pseudo_proportions_fun(x,bdw,time_point,state,pred_probs_object,pseudo_statuses_object)$sd_pseudo_proportions)
 # sd_pseudo_proportions<-sd_pseudo_proportions[!is.na(sd_pseudo_proportions)]
  #plotting
  plot(x=0,y=0,type="n",xlim = c(0,1),ylim=c(0,1),ylab="",xlab="",xaxt="n",yaxt="n",bty="n",...)
  box(...)
  if(xaxt!="n"){
    axis(1, mgp = c(3, -0.2, 0),...)
  }
    if(yaxt!="n"){
    axis(2, mgp = c(3, 0.2, 0),...)
  }
  #if(draw_axes==F) xaxt<-yaxt<-"n" else xaxt<-yaxt<-"s"
  polygon(c(p,rev(p)),c(pseudo_proportions+sd_pseudo_proportions,rev(pseudo_proportions-sd_pseudo_proportions)),col = "#F4C5BF",border = NA)
  lines(p,pseudo_proportions,col="#E2857E",cex=0.4,pch=16,lwd=0.8)
  abline(0,1,col="black",lty=3)
  lines(c(dens_p$x),dens_p$y/scale_factor,col = "#5C8191",pch=16,lwd=0.5,lty=2)
  if(draw_2nd_yaxis==T){
    axis(4,at=seq(0,signif(max(dens_p$y),2)+signif(max(dens_p$y)/5,1),signif(max(dens_p$y)/5,1))/max(dens_p$y),labels = as.character(seq(0,signif(max(dens_p$y),2)+signif(max(dens_p$y)/5,1),signif(max(dens_p$y)/5,1))), mgp = c(3, -0.2, 0),...)
  }
  if(!is.null(col_title)){
    mtext(col_title,line=0.3,cex=0.5)
  }
    if(!is.null(row_title)){
    mtext(row_title,line=row_title_line,cex=row_title_cex,side = 2)
  }
}
```

Model 1 preliminary objects
```{r}

load("../data/pred_probs_model1.Rdata")
#  flds_5<- createFolds(unique(mstate.data$id), k = 5, list = TRUE, returnTrain = FALSE)
# pred_probs_model1<-pred_probs_fun(flds_5,time_points = 365.25*c(1:8),states =list("MDS",c("AML","death_after_AML"),"death"),mstate.data,mstate.data.expanded,group_function,time_model = "semiMarkov",backup_file = "../data/pred_probs_model1_backup.Rdata",input_file ="../data/pred_probs_model1_backup.Rdata")
# save(pred_probs_model1,file = "../data/pred_probs_model1.Rdata")

pseudo_statuses_model1<-pseudo_statuses_fun(patient_indices = pred_probs_model1$patient_indices,time_points = 365.25*c(1:8),states =list("MDS",c("AML","death_after_AML"),"death"),mstate.data.expanded = mstate.data.expanded,tmat =  attr(mstate.data,"trans"),time_model = "semiMarkov")

```

Model 2 preliminary objects
```{r}

load("../data/pred_probs_model2.Rdata")
# pred_probs_model2<-pred_probs_fun(patient_indices = pred_probs_model1$patient_indices,time_points = 365.25*c(1:8),states =list("MDS",c("AML","death_after_AML"),"death") ,mstate.data = mstate.data,mstate.data.expanded = mstate.data.expanded.2,group_function = group_function,time_model = "semiMarkov",backup_file = "../data/pred_probs_model2_backup.Rdata",input_file =NULL)
# save(pred_probs_model2,file="../data/pred_probs_model2.Rdata")
# 
pseudo_statuses_model2<-pseudo_statuses_fun(patient_indices = pred_probs_model2$patient_indices,time_points = 365.25*c(1:8),states =list("MDS",c("AML","death_after_AML"),"death"),mstate.data.expanded = mstate.data.expanded.2,tmat =  attr(mstate.data,"trans"),time_model = "semiMarkov")

```

Model 3 preliminary objects
```{r}

load("../data/pred_probs_model3.Rdata")
# pred_probs_model3<-pred_probs_fun(patient_indices = pred_probs_model1$patient_indices,time_points = 365.25*c(1:8),states =list("MDS",c("AML","death_after_AML"),"death") ,mstate.data = mstate.data.3,mstate.data.expanded = mstate.data.expanded.3,group_function = group_function,time_model = "semiMarkov",backup_file = "../data/pred_probs_model3_backup.Rdata",input_file =NULL)
#save(pred_probs_model3,file="../data/pred_probs_model3.Rdata")

pseudo_statuses_model3<-pseudo_statuses_fun(patient_indices = pred_probs_model1$patient_indices,time_points = 365.25*c(1:8),states =list("MDS",c("AML","death_after_AML"),"death"),mstate.data.expanded = mstate.data.expanded.3,tmat =  attr(mstate.data,"trans"),time_model = "semiMarkov")

```


Grid of calibration plots
```{r}

#model 1
# pred_probs_object<-pred_probs_model1$pred_probs_object
# pseudo_statuses_object<-pseudo_statuses_model1$pseudo_statuses
# output_file<-"../plots/grid_of_calibration_plots_model1.png"

#model 2
# pred_probs_object<-pred_probs_model2$pred_probs_object
# pseudo_statuses_object<-pseudo_statuses_model2$pseudo_statuses
# output_file<-"../plots/grid_of_calibration_plots_model2.png"

#model 2
pred_probs_object<-pred_probs_model3$pred_probs_object
pseudo_statuses_object<-pseudo_statuses_model3$pseudo_statuses
output_file<-"../plots/grid_of_calibration_plots_model3.png"


states<-c("MDS","AML & death_after_AML","death")
col_titles<-c("1 year",paste((2:8),"years"))
row_titles<-c("MDS","AML or\ndeath after AML","death before AML")
bandwidths<-c(0.08,0.05,0.07) 
time_points<-(1:8)*365.25


#grid of calibration plots
png(output_file,height = 3,width = 5,units = "in",res=400)
par(mfrow=c(3,8)
    ,mar=c(0.06,0.06,0.12,0.06),oma=c(2,2,2,2)
    )
for(i in 1:length(states)){
  if(i==length(states)){
    xaxt<-"s"
    }else{
      xaxt<-"n"
    }
  
    p<-sort(unlist(sapply(1:length(pred_probs_object),function(x) pred_probs_object[[x]][,states[i],paste0("t=",time_points[1])])))
  dens_p<-density(p)
  scale_factor<-max(dens_p$y)
  
  for(j in 1:length(time_points)){
    if(i==1) col_title<-col_titles[j] else col_title<-NULL
    if(j==1){
      row_title<-row_titles[i] 
      yaxt<-"s"
    } else {
      row_title<-NULL
      yaxt<-"n"
    }
    if(j==length(time_points)) draw_2nd_yaxis<-TRUE else draw_2nd_yaxis<-FALSE
    plot_fun(time_point = time_points[j],state = states[i],bdw = bandwidths[i],pred_probs_object = pred_probs_object,pseudo_statuses_object = pseudo_statuses_object,draw_2nd_yaxis = draw_2nd_yaxis,col_title = col_title,row_title=row_title,row_title_line = 3,row_title_cex = 0.4,scale_factor = scale_factor,cex.axis=0.38,tck=-0.03,lwd=0.5,xaxt =xaxt,yaxt =yaxt)
    
  }
}
dev.off()
```

A reference calibration plot
```{r}

png("../plots/reference_calibration_plot.png",height = 2.5,width = 5,units = "in",res=300)
par(mfrow=c(1,2),mar=c(2,2,2,2))
plot_fun(time_point = time_points[j],state = states[i],bdw = bandwidths[i],pred_probs_object = pred_probs_object,pseudo_statuses_object = pseudo_statuses_object,draw_2nd_yaxis = FALSE,col_title = NULL,row_title=NULL,scale_factor =2,cex.axis=0.38,tck=-0.03,lwd=0.5,xaxt ="n",yaxt ="n",xaxs="i",yaxs="i")

axis(side = 1, lwd = 0.5,at=c(0,1),cex.axis=0.5,tck=-0.05,line = 0,mgp=c(3,0.3,0))
axis(side = 2, lwd = 0.5,at=c(0,1),cex.axis=0.5,tck=-0.05,mgp=c(3,0.5,0))
axis(side = 4, lwd = 0.5,at=c(0,1),cex.axis=0.5,tck=-0.05,mgp=c(3,0.3,0),labels = c("0","ymax"))
mtext("predicted probability",side=1,line = 0.45,cex = 0.5)
mtext("pseudo-observed proportion",side=2,line = 0.55,cex = 0.5)
mtext("scaled density",side=4,line = 0.45,cex = 0.5)

  par(mar=c(2.6,1.5,2,2),xaxs="i",yaxs="i")
  plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1),axes = F)
  legend(x=0,y=1,legend = c("scaled density","calibration curve","calibration curve\n+-1 std error"),col =c("#5C8191","#E2857E","#F4C5BF"),lty = c(2,1,NA),ncol=1,cex=0.5,pt.cex=c(1,1,1.2),pch=c(NA,NA,15),xpd = T,box.lwd=0.5)

dev.off()

```

#### Other measures of prediction accuracy

Mean absolute error
```{r}
#model 1
# pred_probs_object<-pred_probs_model1$pred_probs_object
# pseudo_statuses_object<-pseudo_statuses_model1$pseudo_statuses
# output_file<-"../tables/mean_abs_error_model1.csv"

#model 2
# pred_probs_object<-pred_probs_model2$pred_probs_object
# pseudo_statuses_object<-pseudo_statuses_model2$pseudo_statuses
# output_file<-"../tables/mean_abs_error_model2.csv"

#model 3
pred_probs_object<-pred_probs_model3$pred_probs_object
pseudo_statuses_object<-pseudo_statuses_model3$pseudo_statuses
output_file<-"../tables/mean_abs_error_model3.csv"

dummy_array<-array(dim = c(length(states),length(time_points),length(pred_probs_object)))
for(i in 1:length(pred_probs_object)){
dummy_array[,,i]<-apply(pred_probs_object[[i]]-pseudo_statuses_object[[i]],2:3,function(x) mean(abs(x)))  
}

mae.matrix<-matrix(apply(dummy_array,c(1,2),mean),nrow=3,dimnames = list(states,time_points))

write.csv(mae.matrix,output_file)
```

k-fold cross-validated concordance: functions
```{r}

# The next function generates cross-validation folds i=1,2...k for each transition. It returns a list with k components, where each component aggregates (or combines) all folds i (i.e. aggregates across transitions). Each (aggregated) fold is made of row names, rather than indices.  
folds_fun<-function(nr_folds,mstate.data.expanded){
  #reserve a test set for each transition
  flds<-vector("list")
  for(i in 1:length(unique(mstate.data.expanded$trans))){
    flds[[i]]<-createFolds(rownames(mstate.data.expanded[mstate.data.expanded$trans==i,]), k = nr_folds, list = TRUE, returnTrain = FALSE)
    flds[[i]]<-lapply(1:length(flds[[i]]), function(x) (rownames(mstate.data.expanded[mstate.data.expanded$trans==i,]))[flds[[i]][[x]]] )
  }
  output_flds<-vector("list")
  for(k in 1:nr_folds){
  output_flds[[k]]<-unlist(sapply(flds,function(x,k) x[[k]],k=k))  
  }
 output_flds 
}
  folds<-folds_fun(nr_folds = 5,mstate.data.expanded = mstate.data.expanded)

#function to generate out-of-sample relative hazard estimates and cross-validated estimates of concordance
concordances_fun<-function(folds,mstate.data.expanded,group_function,time_model="semiMarkov"){
  rel_hazards<-vector("list")
  concordances<-vector("list")
  for(i in 1:length(folds)){
  mstate.data.expanded.train<-mstate.data.expanded[!rownames(mstate.data.expanded)%in%folds[[i]],]
  mstate.data.expanded.test<-mstate.data.expanded[rownames(mstate.data.expanded)%in%folds[[i]],]
  Z_cv<-mstate.data.expanded.train[!names(mstate.data.expanded.train)%in%c("id","from","to","trans","Tstart","Tstop","time","status","type")]
  Z_cv<-Z_cv[,apply(Z_cv,2,function(x) var(x)>0)]
  groups<-sapply(names(Z_cv)[names(Z_cv)!="strata"],group_function)

  #argument 'surv' of coxrfx
  if(time_model=="semiMarkov"){
    surv.cv.train<-Surv(mstate.data.expanded.train$time,mstate.data.expanded.train$status)
    surv.cv.test<-Surv(mstate.data.expanded.test$time,mstate.data.expanded.test$status)
  }else{
    surv.cv.train<-Surv(mstate.data.expanded.train$Tstart,mstate.data.expanded.train$Tstop,mstate.data.expanded.train$status)
    surv.cv.test<-Surv(mstate.data.expanded.test$Tstart,mstate.data.expanded.test$Tstop,mstate.data.expanded.test$status)
  }

  #fit random effects model
  coxrfx_object_cv<-CoxRFX(Z_cv,surv.cv.train,groups,max.iter = 200,which.mu = NULL)

rel_hazards[[i]]<-as.matrix(mstate.data.expanded.test[!names(mstate.data.expanded.test)%in%c("id","from","to","trans","Tstart","Tstop","time","status","type","strata")])%*%coxrfx_object_cv$coefficients
conc_vector<-rep(NA,length(unique(mstate.data.expanded.test$trans)))
names(conc_vector)<-paste("trans",1:length(unique(mstate.data.expanded.test$trans)))
for(j in 1:length(unique(mstate.data.expanded.test$trans))){
  data<-data.frame(surv=surv.cv.test[mstate.data.expanded.test$trans==j,],rel_haz=rel_hazards[[i]][mstate.data.expanded.test$trans==j])
  conc_vector[j]<-concordance(surv~rel_haz,data=data,reverse = T)$concordance
}
concordances[[i]]<-conc_vector

print(i)
  }
  list(rel_hazards=rel_hazards,folds=folds,concordances=concordances)
}
```

k-fold cross-validated concordance: estimation

```{r}
# Model 1
# mstate_data_expanded<-mstate.data.expanded
# output_file<-"../plots/concordances_plot_model1.png"

# Model 2
# mstate_data_expanded<-mstate.data.expanded.2
# output_file<-"../plots/concordances_plot_model2.png"

# Model 3
mstate_data_expanded<-mstate.data.expanded.3
output_file<-"../plots/concordances_plot_model3.png"

concordances_object<-concordances_fun(folds = folds,mstate.data.expanded = mstate_data_expanded,group_function = group_function,time_model = "semiMarkov")

png(output_file,height = 4,width = 5,units = "in",res=300)
plot_concordances<-function(concordances_object){
  plot(1, type="n", xlab="transition", ylab="", xlim=c(0.8,length(concordances_object$concordances[[1]])+0.2 ),xaxt="n", ylim=c(0, 1),yaxt="n")
  axis(side = 1,at=1:length(concordances_object$concordances[[1]]))
  axis(side=2,at=seq(0,1,0.25),labels = )
  abline(h=0.5,lty=2,col="red")
  for(i in 1:length(concordances_object$concordances[[1]])){
    points(x=rep(i,length(concordances_object$concordances)),y=sapply(concordances_object$concordances,function(x) x[i]))
  }
}

plot_concordances(concordances_object = concordances_object)

dev.off()
```



#### MDS data summary table

Build data frame with summary statistics (to be exported to excel and converted to pdf).

Build non-expanded covariate data set; only covariates used in the final analysis.
```{r}

covariate_names<-names(mstate.data.expanded)[sapply(names(mstate.data.expanded),function(x) tail(unlist(strsplit(x,split="[.]")),1))=="1"]

covariate_names<-gsub(".1","",covariate_names,fixed = T)
covariate_names[covariate_names=="center"]<-"center.1"

covariate_data<-imputedDataNonCentered[names(imputedDataNonCentered)%in%covariate_names]

```

Undo log and logit transformations
```{r}
undo_log<-function(x){
  if(grepl("logit",names(covariate_data)[x])==T){
    return(exp(covariate_data[x])/(exp(covariate_data[x])+1))
  }else if(grepl("log",names(covariate_data)[x])==T){
    return(exp(covariate_data[x]))
  }else{
    return(covariate_data[x])
  }
}

covariate_data<-data.frame(sapply(1:length(covariate_data),undo_log))
covariate_data$date<-covariate_data$date*10000

```

Compute summary statistics 
```{r}
summary_stat_fun<-function(statistic){
  apply(covariate_data,2,statistic)
}
covs_table<-round(data.frame(sapply(c(min,max,mean,sd),summary_stat_fun)),2)

# summary_stat_fun<-function(cov_type,statistic){
#   apply(covariate_data[names(covariate_data)%in%cov_type],2,statistic)
# }
# binary_covs_table<-data.frame(summary_stat_fun(covariate_classes$logical_covs,function(x)sum(x)/length(x)))
# numeric_covs_table<-data.frame(sapply(c(min,max,mean),summary_stat_fun,cov_type=c(covariate_classes$numeric_covs,covariate_classes$factor_covs)))
```

Transpose data frames
```{r}

# binary_covs_table<-as.data.frame(t(as.matrix(binary_covs_table)))
# numeric_covs_table<-as.data.frame(t(as.matrix(numeric_covs_table)))
```

Changing names and other formating.
```{r}
rownames(covs_table)<-gsub("_simple_factor","",rownames(covs_table))
rownames(covs_table)<-gsub("_logit","",rownames(covs_table),fixed = T)
rownames(covs_table)<-gsub("_log","",rownames(covs_table),fixed = T)

colnames(covs_table)<-c("min","max","mean","std dev")
covs_table<-as.data.frame(t(covs_table))
covs_table[,"date"]<-as.Date(unlist(covs_table[,"date"]),origin = "1970-01-01")
write.csv(covs_table,"../tables/numeric_covs_table.csv")

```


#### Plots for package summary figure

Relative hazard plot
```{r }

labels_fun<-function(n){
  result_pos<-vector("numeric",0)
  result_neg<-vector("numeric",0)
  for(i in 1:n){
    result_pos<-c(result_pos,c(rep(NA,8),10^i))
  }
    for(i in 1:n){
    result_neg<-c(result_neg,c(rep(NA,8),10^-i))
  }
  as.character(c(rev(result_neg),1,result_pos))
}
coefs_plot_fun2<-function(k,mar=NULL){
  #keep only covariate names from transition k
  string_split<-strsplit(names(coxrfx_object$coefficients),"[.]")
  is_name_from_trans_k<-sapply(string_split,function(x) x[length(x)]==as.character(k))
  CI_labels<-names(coxrfx_object$coefficients)[is_name_from_trans_k]
  #get rid of suffix ".k"
  CI_labels_split<-strsplit(CI_labels,"[.]")
  CI_labels<-sapply(CI_labels_split,function(x) paste0(x[-length(x)],collapse = "."))
  CI_labels<-c("age","male","...","gene 1","gene 2","...")

  #log-scale on the x-axis
  max_dist_x_axis<-max(abs(boot_coefs[c(1,2),seq(k,ncol(boot_coefs),3)]))
  x_axis_positive_ticks<-log(c(seq(1,9,1),seq(10,90,10),seq(100,900,100),seq(1000,9000,1000),seq(10000,100000,10000)))
  x_axis_negative_ticks<-log(c(seq(0.9,0.2,-10^(-1)),seq(0.1,0.02,-10^(-2)),seq(0.01,0.002,-10^(-3)),seq(0.001,0.0002,-10^(-4)),seq(0.0001,0.00001,-10^(-5))))
  x_axis_ticks<-c(rev(x_axis_negative_ticks),x_axis_positive_ticks)
  x_axis_labels<-labels_fun(5)
  
  par(bty="o", mgp=c(2,3,0),bg=rgb(231,230,230,maxColorValue = 255))
  old_mar<-par()$mar
  if(!is.null(mar)) par(mar=mar)
  plot(1, type="n", xlab="",yaxt="n",xaxt="n",
       #xlim=c(-max_dist_x_axis,+max_dist_x_axis),
       xlim=c(log(0.1),log(10)),
       ylim=c(1.6-0.3, length(CI_labels)+0.3),cex=3)
  abline(h=c(6,5,3.4,2.4),lty=3,col="gray",lwd=4)
  plotCI(add=T,y=c(6,5,3.4,2.4), x=coxrfx_object$coefficients[is_name_from_trans_k][c(2,3,5,6)],ui=boot_coefs[2,is_name_from_trans_k],li=boot_coefs[1,is_name_from_trans_k],ylab="",xaxt="n",cex=3,err = "x", ylim=c(1+0.5, length(CI_labels)-0.5),pch=16,lwd=4)
    axis(side = 1,at = x_axis_ticks,cex.axis=3,labels = labels_fun(5),lwd.ticks = 3,tck=-0.02)
    #longer tick marks
    axis(side = 1, cex=3,at =log(c(10^-4,10^-3,10^-2,10^-1,1,10,10^2,10^3,10^4)),cex.axis=4,labels =F,lwd.ticks = 3,tck=-0.03)
    abline(v=0,lty=2,col=2,lwd=4)
     text(labels = CI_labels,x=log(0.1)-0.3,y=c(6,5,4.2,3.4,2.4,1.6),xpd=NA,font=1,cex = 2.7,adj=1)
  #axis(side=1, at=1)
  par(mar=old_mar)
}
```

```{r fig.width=9,fig.height=9}
pdf("../plots/summary_fig_coefs.pdf")
colGroups <- c(brewer.pal(12, "Paired")[c(10)],brewer.pal(12, "Paired")[c(6,4,3,5,12,9,1,2,7)],"#999999", brewer.pal(12, "Paired")[c(8)])
colGroups <- colGroups[rep(1:6,3)]
par(mfrow=c(1,1),oma=c(4,8,2,0),lwd=2)
coefs_plot_fun2(1,mar =c(4.1,1,3.1,0.4))
mtext("relative hazard (log scale)",side=1, outer=T,line=1.6,cex=2)
mtext(expression(paste("State transition",italic(" x"),)),side=3, outer=F,line=2,cex=3)
dev.off()

```

A sample plot of transition probabilities 
```{r , fig.width=4,fig.height=4}

pdf("../plots/sample_plot_trans_probs.pdf",width = 5,height = 4)
par(mar=c(4,4,1,3),bg=rgb(231,230,230,maxColorValue = 255))
probtrans_list_reference_patient<-probtrans_list[[2]]
#swap order of states
probtrans_list_reference_patient[[1]]<-probtrans_list_reference_patient[[1]][c(1,2,3,5,4)]
dimnames(probtrans_list_reference_patient$trans)[[2]]<-c("","","","")
probtrans_list_reference_patient[[1]][,1]<-probtrans_list_reference_patient[[1]][,1]/365.25

plot(probtrans_list_reference_patient,type="filled",xlim=c(0,4000/365.25),lwd=0.001,col=c("#F4C5BF","#E2857E","#5C8191","#9DB6BD"),xlab = "")
mtext("years since diagnosis",side=1, outer=F,line=2.3,cex=1)
text(x=2,y=0.3,labels="state 1",cex = 1,font=1)
text(x=8.2,y=0.2,labels="state 2",cex = 1,font=1)
segments(x0=9.2,y0=0.2,x1=9.8,y1=0.23)
text(x=8.6,y=0.89,labels="state 4",cex = 1,font=1)
text(x=9,y=0.65,labels="state 3",cex = 1,font=1)
segments(x0=9,y0=0.61,x1=8,y1=0.5)

# text(x=3.38,y=0.25,labels="overall survival 95% CI",cex = 0.8)

# lines(as.numeric(colnames(probtrans_boot_CIs))/365.25,probtrans_boot_CIs[1,],lty=2)
# lines(as.numeric(colnames(probtrans_boot_CIs))/365.25,probtrans_boot_CIs[2,],lty=2)
dev.off()
```

